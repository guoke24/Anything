接着上一片文章的代码段3，接着追踪
* 代码段3:
* /frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV2Verifier.java
```
    /**
     * Verifies APK Signature Scheme v2 signatures of the provided APK and returns the certificates
     * associated with each signer.
     *
     * @throws SignatureNotFoundException if the APK is not signed using APK Signature Scheme v2.
     * @throws SecurityException if an APK Signature Scheme v2 signature of this APK does not
     *         verify.
     * @throws IOException if an I/O error occurs while reading the APK file.
     */
    private static X509Certificate[][] verify(RandomAccessFile apk)
            throws SignatureNotFoundException, SecurityException, IOException {
        SignatureInfo signatureInfo = findSignature(apk);//3-1 提取签名信息
        return verify(apk.getFD(), signatureInfo);//3-2 验证签名信息
    }
```

由上篇文章可知，3-1处返回的是签名信息的结构体，该示例内含几个字段，带有分离apk后，提取出来的签名块信息。
3-2处就是接着区验证提取处的签名块是否OK。

进入3-2处函数：verify(apk.getFD(), signatureInfo)
该函数定义在：
frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV2Verifier.java
代码段4
```
    private static X509Certificate[][] verify(
            FileDescriptor apkFileDescriptor,
            SignatureInfo signatureInfo) throws SecurityException {
        int signerCount = 0;
        Map<Integer, byte[]> contentDigests = new ArrayMap<>();
        List<X509Certificate[]> signerCerts = new ArrayList<>();
        CertificateFactory certFactory;
        try {
            certFactory = CertificateFactory.getInstance("X.509");
        } catch (CertificateException e) {
            throw new RuntimeException("Failed to obtain X.509 CertificateFactory", e);
        }
        ByteBuffer signers;
        try {
            // 入参的 signatureInfo.signatureBlock 是不带 头8字节和 4字节id 的
            signers = getLengthPrefixedSlice(signatureInfo.signatureBlock);
            // 获前四个字节的int数值作为字节数，然后再取该字节数个数的字节段，返回
        } catch (IOException e) {
            throw new SecurityException("Failed to read list of signers", e);
        }
        while (signers.hasRemaining()) {
            signerCount++;
            try {
                ByteBuffer signer = getLengthPrefixedSlice(signers);
                // signers 实际上是由 n 个 len-value 对组成，每一次取一个len，再返回len个字节的value数值，
                // 接着 signers 的下标又移动到下一个 len-value 对的开始

                X509Certificate[] certs = verifySigner(signer, contentDigests, certFactory);//验签的主要逻辑
                signerCerts.add(certs);
            } catch (IOException | BufferUnderflowException | SecurityException e) {
                throw new SecurityException(
                        "Failed to parse/verify signer #" + signerCount + " block",
                        e);
            }
        }

        if (signerCount < 1) {
            throw new SecurityException("No signers found");
        }

        if (contentDigests.isEmpty()) {
            throw new SecurityException("No content digests found");
        }

        verifyIntegrity(
                contentDigests,
                apkFileDescriptor,
                signatureInfo.apkSigningBlockOffset,
                signatureInfo.centralDirOffset,
                signatureInfo.eocdOffset,
                signatureInfo.eocd);

        return signerCerts.toArray(new X509Certificate[signerCerts.size()][]);
    }
```

