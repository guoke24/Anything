在前两篇文章：《V2验签流程源码记录.md》和《V2验签流程源码记录2.md》的探索下，基本摸清里v2验签的流程和对应的源码。
再次做一个总结，记录大致的流程和对应的源码，如后续需要，还可以深入研究其中的细节。


# 主要看这三篇文章
官方文档，以此为准，最全最权威，但需要翻墙：
https://source.android.com/security/apksigning/v2
加签的源码解析：
https://www.jianshu.com/p/dc320629bf9d
辅助理解：
https://blog.csdn.net/freekiteyu/article/details/84849651



### 引用于官方文档 start ###

APK 签名分块

为了保持与 v1 APK 格式向后兼容，v2 及更高版本的 APK 签名会存储在“APK 签名分块”内，该分块是为了支持 APK 签名方案 v2 而引入的一个新容器。
在 APK 文件中，“APK 签名分块”位于“ZIP 中央目录”（位于文件末尾）之前并紧邻该部分。

该分块包含多个“ID-值”对，所采用的封装方式有助于更轻松地在 APK 中找到该分块。APK 的 v2 签名会存储为一个“ID-值”对，其中 ID 为 0x7109871a。
格式

“APK 签名分块”的格式如下（所有数字字段均采用小端字节序）：

    size of block，以字节数（不含此字段）计 (uint64)
    带 uint64 长度前缀的“ID-值”对序列：
        ID (uint32)
        value（可变长度：“ID-值”对的长度 - 4 个字节）
    size of block，以字节数计 - 与第一个字段相同 (uint64)
    magic“APK 签名分块 42”（16 个字节）

在解析 APK 时，首先要通过以下方法找到“ZIP 中央目录”的起始位置：在文件末尾找到“ZIP 中央目录结尾”记录，然后从该记录中读取“中央目录”的起始偏移量。
通过 magic 值，可以快速确定“中央目录”前方可能是“APK 签名分块”。然后，通过 size of block 值，可以高效地找到该分块在文件中的起始位置。

在解译该分块时，应忽略 ID 未知的“ID-值”对。


APK 签名方案 v2 分块

APK 由一个或多个签名者/身份签名，每个签名者/身份均由一个签名密钥来表示。该信息会以“APK 签名方案 v2 分块”的形式存储。对于每个签名者，都会存储以下信息：

    （签名算法、摘要、签名）元组。摘要会存储起来，以便将签名验证和 APK 内容完整性检查拆开进行。
    表示签名者身份的 X.509 证书链。
    采用键值对形式的其他属性。

对于每位签名者，都会使用收到的列表中支持的签名来验证 APK。签名算法未知的签名会被忽略。如果遇到多个支持的签名，则由每个实现来选择使用哪个签名。这样一来，以后便能够以向后兼容的方式引入安全系数更高的签名方法。建议的方法是验证安全系数最高的签名。
格式

“APK 签名方案 v2 分块”存储在“APK 签名分块”内，ID 为 0x7109871a。

“APK 签名方案 v2 分块”的格式如下（所有数字值均采用小端字节序，所有带长度前缀的字段均使用 uint32 值表示长度）：

    带长度前缀的 signer（带长度前缀）序列：
        带长度前缀的 signed data：
            带长度前缀的 digests（带长度前缀）序列：
                signature algorithm ID (uint32)
                （带长度前缀）digest - 请参阅受完整性保护的内容
            带长度前缀的 X.509 certificates 序列：
                带长度前缀的 X.509 certificate（ASN.1 DER 形式）
            带长度前缀的 additional attributes（带长度前缀）序列：
                ID (uint32)
                value（可变长度：附加属性的长度 - 4 个字节）
        带长度前缀的 signatures（带长度前缀）序列：
            signature algorithm ID (uint32)
            signed data 上带长度前缀的 signature
        带长度前缀的 public key（SubjectPublicKeyInfo，ASN.1 DER 形式）

### 引用于官方文档 end ###

备注：要重点注意这句话"该分块包含多个“ID-值”对"，其意思就是，原生的v2签名分块只是作为一个“ID-值”对 存储于 APK 签名分块中 。

有了上面的概念理解，接着我们去追踪源码中，v2验签的实现。

v2验签流程开始的源码位置：
* 代码段1:
```
/frameworks/base/core/java/android/content/pm/PackageParser.java
private static void collectCertificates(Package pkg, File apkFile, int parseFlags)
            throws PackageParserException {
	final String apkPath = apkFile.getAbsolutePath();
	......
	// Try to verify the APK using APK Signature Scheme v2.
        boolean verified = false;
        {
            Certificate[][] allSignersCerts = null;
            Signature[] signatures = null;
            try {
                Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "verifyV2");
                allSignersCerts = ApkSignatureSchemeV2Verifier.verify(apkPath);//1-1 v2 验签入口
                signatures = convertToSignatures(allSignersCerts);//证书转换为签名
                // APK verified using APK Signature Scheme v2.
                verified = true;//1-2 v2 验签标识位置为true
            } catch (ApkSignatureSchemeV2Verifier.SignatureNotFoundException e) {
                // No APK Signature Scheme v2 signature found
            } catch (Exception e) {
                // APK Signature Scheme v2 signature was found but did not verify
                throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES,
                        "Failed to collect certificates from " + apkPath
                                + " using APK Signature Scheme v2",
                        e);
            } finally {
                Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
            }

            // 如果v2验证通过，则把提取出来的证书集的公钥逐个存到变量 pkg.mSigningKeys，后续的安装流程需要用到
            if (verified) {
                if (pkg.mCertificates == null) {
                    pkg.mCertificates = allSignersCerts;
                    pkg.mSignatures = signatures;
                    pkg.mSigningKeys = new ArraySet<>(allSignersCerts.length);
                    for (int i = 0; i < allSignersCerts.length; i++) {
                        Certificate[] signerCerts = allSignersCerts[i];
                        Certificate signerCert = signerCerts[0];
                        pkg.mSigningKeys.add(signerCert.getPublicKey());
                    }
                } else {
                    if (!Signature.areExactMatch(pkg.mSignatures, signatures)) {
                        throw new PackageParserException(
                                INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES,
                                apkPath + " has mismatched certificates");
                    }
                }
                // Not yet done, because we need to confirm that AndroidManifest.xml exists and,
                // if requested, that classes.dex exists.
            }
            // 至此v2验签结束
        }
	......
}
```
该段代码，展示了v2验签的整个流程的主要框架。
注释1-1处，开始进入验签流程，如验签过程出错，就会抛异常，整个函数都会终止。
注释1-2处，如果顺利执行到此处，就认为验签已经通过，将标识位设置为true。