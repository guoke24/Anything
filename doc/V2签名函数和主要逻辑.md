# 顶层函数逻辑展开
//1-0
sign函数，入参：inputApk（待签名apk的字节），signerConfigs（签名者配置集）

    // 1-1，从1-0处的 inputApk 提取出了三部分：
    beforeCentralDir，centralDir，eocd

    // 1-2，加载摘要算法到集合，从1-0处的 signerConfigs 中加载
    contentDigestAlgorithms

    // 1-3，取得 "摘要算法ID - 分块摘要序列的摘要"的 Map
    contentDigests = computeContentDigests函数，入参：1-1处 和 1-2处 的结果

    // 1-4，构造 apk 签名分块
    apkSigningBlock = generateApkSigningBlock函数，入参：1-3处的结果，1-0处的 signerConfigs

    // 1-5 构造并返回 V2签名 APK
    return new ByteBuffer[] {
        beforeCentralDir,
        apkSigningBlock,// apk 签名分块
        centralDir,
        eocd,
    };
====================================================================================================


# 1-4处的函数逻辑展开
//4-0
generateApkSigningBlock函数，入参：signerConfigs（签名者配置集），contentDigests（"摘要算法ID - 分块摘要序列的摘要"的 Map）

    //4-1，构造原生V2签名分块value值
    apkSignatureSchemeV2Block =
                generateApkSignatureSchemeV2Block函数，入参（同4-0）：signerConfigs，contentDigests

    //4-2，构造完整的 apk 签名分块
    return generateApkSigningBlock函数，入参：4-1处的结果

====================================================================================================


# 4-1处的函数逻辑展开
//1-0
generateApkSignatureSchemeV2Block函数，入参：signerConfigs（签名者配置集），contentDigests（"摘要算法ID - 分块摘要序列的摘要"的 Map）

    //1-1 循环地：用 签名者配置 构造 signer 块，
    signerBlock = generateSignerBlock函数，入参：signerConfig（遍历1-0处的signerConfigs）, 1-0处的 contentDigests

    // 每个 signer 块添加到 signerBlocks
    signerBlocks.add(signerBlock);

    //1-2 前缀构造
    return encodeAsSequenceOfLengthPrefixedElements(
                    new byte[][] {
                            encodeAsSequenceOfLengthPrefixedElements(signerBlocks),
                            // 对每个 signer 追加长度前缀
                    });

====================================================================================================


# 1-1处的函数逻辑展开
//1-0
generateSignerBlock函数，入参：signerConfig（签名者配置集中的一个），contentDigests（"摘要算法ID - 分块摘要序列的摘要"的 Map）
//备注，该函数是最复杂的核心函数

// 先看 signerConfig 类的结构，只带有三个成员变量：
signerConfig类{
    privateKey // 私钥
    certificates // 证书链
    signatureAlgorithms // 签名算法链条
}

    //1-1，获得公钥，从 signerConfig 之中
    signer.publicKey = encodedPublicKey;

    //1-2 获得证书链，从 signerConfig 之中
    signedData.certificates

    //1-3 "签名算法ID - 分块摘要序列的摘要"的 Map，
    //每个 签名算法ID，先找出对应的 摘要算法ID，再根据 摘要算法ID，找出 分块摘要序列的摘要，
    //最后构造成"签名算法ID - 分块摘要序列的摘要"对，保存到集合
    signedData.digests

    //1-4 构造 signedData 数据，以 1-3处的 signedData.digests，1-2处的 signedData.certificates 为源，添加前缀
    signer.signedData = encodeAsSequenceOfLengthPrefixedElements(new byte[][] {
                    encodeAsSequenceOfLengthPrefixedPairsOfIntAndLengthPrefixedBytes(signedData.digests),//x-1
                    encodeAsSequenceOfLengthPrefixedElements(signedData.certificates),//x-2
                    new byte[0],//x-3
            });
    //x-1处的具体构造逻辑：
    // 入参 signedData.digests，内有多个 "签名算法ID-摘要" pair
    // 返回值：byte[],包含多个 "pair长度前缀 -（ 签名算法ID -（摘要长度前缀-摘要））" 对
    //x-2处的具体构造逻辑：
    // 入参 signedData.certificates，内有多个 certificate
    // 返回值：byte[],包含多个"长度前缀-certificate"
    //
    //signer.signedData 不带总长度前缀，仅内部元素带长度前缀
    //signer.signedData 接下来将被整个签名

    //1-5 构造 signatures 数据，以 1-4处的 signer.signedData 为源，逐个 signatureAlgorithm （signerConfig.signatureAlgorithms中的每一个）
    //对 signer.signedData 进行签名，签名结果 signatureBytes
    //然后将每个 signatureAlgorithm - signatureBytes 保存到集合
    signer.signatures

    //1-6 构造长度前缀
    return encodeAsSequenceOfLengthPrefixedElements(
        new byte[][] {
            signer.signedData,
            encodeAsSequenceOfLengthPrefixedPairsOfIntAndLengthPrefixedBytes(
                signer.signatures),
            signer.publicKey,
        });























